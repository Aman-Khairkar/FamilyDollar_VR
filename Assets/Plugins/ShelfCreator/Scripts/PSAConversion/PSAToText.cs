using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using JDA;
using System.IO;
using System.Linq;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using System;
#if UNITY_EDITOR && ALLOW_SHELF_BUILD_IN_EDITOR
using UnityEditor;
#endif

[ExecuteInEditMode]
public class PSAToText : MonoBehaviour
{
    public const string ORGANIZE_PRODUCTS_BY_SEGMENT_AND_LAYER = "OrganizeProductsBySegmentAndLayer";
    public const string CREATED_IN_UNITY_VERSION_OLDER_THAN_2018_3 = "OriginallyCreatedInUnityVersionOlderThan2018.3";

    // The directory in the project where shelf prefabs should go
    static string shelfPrefabFolderPath = "Assets/Shelves";
    public static string CurrentShelfSaveFolder
    {
        get
        {
            return shelfPrefabFolderPath + "/" + psaFileName + "_" + PsaManager.Instance.LoadedPSA.TheProject.Name;
        }
    }

    static string psaFileName;

	//the amount by which to shift the next planogram we create, so that strategies are placed properly
	float nextPlanogramPosition = 0.0f;
    //the amount of space we want between two planograms so it's easy to tell where one strategy ends and the next begins
    float spaceBetweenPlanograms = 50.0f;

    //these are set to the parent scale to convert between metric and imperial
    const float METRIC_CONVERSION_FACTOR = 0.01f;
    const float IMPERIAL_CONVERSION_FACTOR = 0.025399f;

    //to retain the last folder path.
    private static string _previousFolderPath = null;

    private static bool organizeProductsBySegmentAndLayer = true;
    public static bool OrganizeProductsBySegmentAndLayer
    {
        get
        {
            return organizeProductsBySegmentAndLayer;
        }
    }
    private static bool createdInUnityVersionOlderThan2018_3;

    public static bool IsRebuildingExistingShelf;
    public static GameObject ShelfSelectedForRebuild;

#if UNITY_EDITOR && ALLOW_SHELF_BUILD_IN_EDITOR
    public void ImportNewPSA()
    {
        IsRebuildingExistingShelf = false;
        ShelfSelectedForRebuild = null;

        string folderPath = string.IsNullOrEmpty(_previousFolderPath) ? Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) : _previousFolderPath;
        string psaFilePath = EditorUtility.OpenFilePanel("Open PSA File", folderPath, "psa");

        // If the user cancelled out of the file browser, don't continue.
        if (psaFilePath == "")
        {
            //Debug.Log("Cancelled.");
            return;
        }

        // Save the path of the previous folder only if the user picked a file
        _previousFolderPath = psaFilePath;

        ImportPSA(psaFilePath);
    }

    public void ReimportExistingPSA(GameObject existingPSA)
    {
        IsRebuildingExistingShelf = true;
        ShelfSelectedForRebuild = existingPSA;

        // Get the path of the prefab in the project
        string prefabPath = PrefabUtility.GetPrefabAssetPathOfNearestInstanceRoot(existingPSA);

        if (!string.IsNullOrEmpty(prefabPath))
        {
            // Convert relative prefab path to absolute path
            string prefabAbsolutePath = Path.GetFullPath(prefabPath);

            // Use the path of the prefab to find the path of the shelf folder
            string shelfFolderPath = Path.GetDirectoryName(prefabAbsolutePath);

            // Find all PSAs in the shelf folder
            string[] psaFilePaths = Directory.GetFiles(shelfFolderPath, "*.psa");

            if (psaFilePaths.Length > 0)
            {
                // The string that appears at the beginning of the backup PSA files automatically generated by JDA Space Planning
                string backupString = "Backup of ";

                // Default to using the first PSA file we found
                string bestPsaFilePath = psaFilePaths.FirstOrDefault();

                // Find the PSA file with the fewest occurences of the backup string
                int minBackupStringOccurrences = int.MaxValue;
                foreach (string psaFilePath in psaFilePaths)
                {
                    // If this is not an empty string
                    if (!string.IsNullOrEmpty(psaFilePath))
                    {
                        // Find how many times the backup string appears in this PSA's file path
                        int backupStringOccurrences = CountStringOccurrences(psaFilePath, backupString);

                        // If this PSA has fewer occurrences of the backup string than any we've looked at so far
                        if (backupStringOccurrences < minBackupStringOccurrences)
                        {
                            // Record this as the new best PSA file path
                            minBackupStringOccurrences = backupStringOccurrences;
                            bestPsaFilePath = psaFilePath;
                        }
                    }
                }
                // If bestPsaFilePath name is file path of autosaved file, check if there is originl file available to import PSA. 
                string bestPSAFileName = Path.GetFileNameWithoutExtension(bestPsaFilePath);
                string autoSaveString = "Autosave of ";

                if (bestPSAFileName.StartsWith(autoSaveString))
                {
                    string actualFileName = bestPSAFileName.Replace(autoSaveString, string.Empty);//bestPSAFileName.Remove(0, autoSaveString.Length);
                    string actualFilePath = Path.Combine(shelfFolderPath, actualFileName + ".psa");

                    // if file is available in folder other than Autosaved file, import the other PSA file.
                    if (File.Exists(actualFilePath))
                    {
                        bestPsaFilePath = actualFilePath;
                    }
                }
                // Import the PSA
                ImportPSA(bestPsaFilePath);
            }
            else
            {
                Debug.Log("No psa file found.");
            }
        }
        else
        {
            Debug.Log("Shelf is not linked to a prefab, cannot find PSA file.");
        }
    }

    /// <summary>
    /// Count occurrences of strings.
    /// Code from https://www.dotnetperls.com/string-occurrence
    /// </summary>
    public static int CountStringOccurrences(string text, string pattern)
    {
        // Loop through all instances of the string 'text'.
        int count = 0;
        int i = 0;
        while ((i = text.IndexOf(pattern, i)) != -1)
        {
            i += pattern.Length;
            count++;
        }
        return count;
    }

    /// <summary>
    /// This handles the initial text decoding of the PSA file.
    /// </summary>
    public void ImportPSA(string psaFilePath)
    {
        // if our hierarchy structure option value is available in the PlayerPrefs
        if (PlayerPrefs.HasKey(PSAToText.ORGANIZE_PRODUCTS_BY_SEGMENT_AND_LAYER))
        {
            organizeProductsBySegmentAndLayer = PlayerPrefs.GetInt(PSAToText.ORGANIZE_PRODUCTS_BY_SEGMENT_AND_LAYER) != 0;
        }
        else
        {
            // True by default
            organizeProductsBySegmentAndLayer = true;
        }

        // if our original unity version value is available in the PlayerPrefs
        if (PlayerPrefs.HasKey(PSAToText.CREATED_IN_UNITY_VERSION_OLDER_THAN_2018_3))
        {
            createdInUnityVersionOlderThan2018_3 = PlayerPrefs.GetInt(PSAToText.CREATED_IN_UNITY_VERSION_OLDER_THAN_2018_3) != 0;
        }
        else
        {
            // False by default
            createdInUnityVersionOlderThan2018_3 = false;
        }

        nextPlanogramPosition = 0;
        
        if (File.Exists(psaFilePath))
        {
            //get the filename to name it later
            bool importSucceeded = PsaManager.Instance.ImportPsa(psaFilePath);

            PsaManager.Instance.PlanogramsSelectedForInteraction.Clear();

            // Mark that we want to build all of the strategies available
            for (int i = 0; i < PsaManager.Instance.LoadedPSA.TheProject.Planograms.Count; i++)
            {
                PsaManager.Instance.PlanogramsSelectedForInteraction.Add(i);
            }

            //make sure we have a PSA, the PSA has a project, and there are planograms inside of the PSA
            //please read up on the JDALibrary documentation to understand the organization of PSA files
            if (importSucceeded
                && PsaManager.Instance.LoadedPSA != null 
                && PsaManager.Instance.LoadedPSA.TheProject != null 
                && PsaManager.Instance.LoadedPSA.TheProject.Planograms != null)
            {
                psaFileName = Path.GetFileNameWithoutExtension(PsaManager.Instance.LoadedPsaPath);
                PsaManager.Instance.MaterialsFolderPath = CurrentShelfSaveFolder;

                PsaManager.Instance.BuildPsaWithSeparateIndividualProductsInPositions(psaFileName);
            }
        }
    }

    public void ProcessPlanogram(PsaIntegrationLibraryEventHandlers.SpawnedPlanogram planogramInfo)
    {
        if (OrganizeProductsBySegmentAndLayer)
        {
            //set products as children of segments
            SetPositionsToChildrenOfSegments(planogramInfo);
            //set layers as children of segments
            SetPositionsToChildrenOfLayers(planogramInfo);
        }

        // Special handling of products on bars
        // (Separate loop from the following one because we need the colliders for this)
        foreach (GameObject positionGameObject in planogramInfo.PositionsGOs)
        {
            //determine if the position is placed on a peg
            CheckProductForBarIntersection(positionGameObject, planogramInfo);
        }     
    }

    /// <summary>
    /// Simplify the hierarchy further to allow each individual product to be separate and therefore more easily accessable
    /// </summary>
    /// <param name="planogramInfo">One of the planograms from the selected PSA</param>
    public void SimplifyHierarchy(PsaIntegrationLibraryEventHandlers.SpawnedPlanogram planogramInfo)
    {    
        Transform theShelf = planogramInfo.PlanogramGameObject.transform;

        PriceTags.PriceTag[] priceTags = theShelf.transform.GetComponentsInChildren<PriceTags.PriceTag>();
        if (priceTags.Length > 0)
        {
            //Create a GO to contain all the price tags to declutter the shelf's hierarchy
            GameObject priceTagParent = new GameObject("PriceTags");
            priceTagParent.transform.parent = theShelf;

            //Move the price tags to be children of the shelf so we can destroy the positionGOs now that they're essentially empty
            foreach (PriceTags.PriceTag pTag in priceTags)
            {
                pTag.transform.parent = priceTagParent.transform;
            }
        }

        // For each position object
        for (int i = 0; i < planogramInfo.PositionsGOs.Count; i++)
        {
            // For each child of the position object
            for (int j = planogramInfo.PositionsGOs[i].transform.childCount - 1; j >= 0; j--)
            {
                Transform potentialProductRow = planogramInfo.PositionsGOs[i].transform.GetChild(j);

                // For a product row
                if (potentialProductRow.name.StartsWith("ProductRow"))
                {
                    // Set all of its children to be children of the shelf
                    while (potentialProductRow.childCount > 0)
                    {
                        Transform child = potentialProductRow.GetChild(0);
                        child.parent = theShelf;
                    }
                }
                // For caps
                else if (!potentialProductRow.name.StartsWith("Position(Clone)") && !potentialProductRow.name.StartsWith("Mesh"))
                {
                    // Set it as a child of the shelf
                    potentialProductRow.parent = theShelf;
                }
            }
            
            //Destroy the positionGO now that it's essentially empty
            DestroyImmediate(planogramInfo.PositionsGOs[i]);
        }           
    }

    public void CleanUpComponents(PsaIntegrationLibraryEventHandlers.SpawnedPlanogram planogramInfo)
    {
        if (planogramInfo.PositionsGOs == null)
        {
            return;
        }

        // Now that we've attached all the positions to their proper segments and layers, 
        // we can get rid of their colliders and rigidbodies (since we gave one to each product already)
        foreach (GameObject positionGameObject in planogramInfo.PositionsGOs)
        {
            // Get rid of the position's collider, we'll replace it with individual product colliders
            Collider positionCollider = positionGameObject.GetComponent<Collider>();
            DestroyImmediate(positionCollider);

            // Get rid of the position's rigidbody, we'll replace it with individual product rigidbodies
            Rigidbody positionRigidbody = positionGameObject.GetComponent<Rigidbody>();
            DestroyImmediate(positionRigidbody);
        }
    }

    public GameObject ReplacePlanogramWithPrefab(GameObject newParent, PSA.Planogram strategy)
    {
        // Get some important locations and names
        //name the parent object based on both the filename and the planogram name
        string objectName = (psaFileName + "_" + strategy.Name);
        string prefabPath = CurrentShelfSaveFolder + "/" + objectName + ".prefab";

        // Create/update the prefab for this shelf and connect our Game Object to the prefab.
        GameObject prefabLinkedParent = SetUpPrefab(newParent, CurrentShelfSaveFolder, prefabPath);
        prefabLinkedParent.name = objectName;

        //set the position of the planogram
        prefabLinkedParent.transform.position = new Vector3(nextPlanogramPosition, 0, 0);
        //calculate the position of the next planogram (this planogram's left x-coordinate + its width + spacing)
        nextPlanogramPosition = prefabLinkedParent.transform.localPosition.x + (strategy.Width + spaceBetweenPlanograms) * GetConversionFactor();

        return prefabLinkedParent;
    }

    public void SavePsaFileInAssetsFolder()
    {
        string destinationPath = CurrentShelfSaveFolder + "/" + psaFileName + ".psa";
        //Create a copy of the PSA file selected
        if (!File.Exists(destinationPath))
        {
            FileUtil.CopyFileOrDirectory(PsaManager.Instance.LoadedPsaPath, destinationPath);
        }
        //or if a copy already exists (and we're not trying to replace the file with itself), ensure we have the latest PSA file and replace it
        else if (PsaManager.Instance.LoadedPsaPath != Path.GetFullPath(destinationPath))
        {
            FileUtil.ReplaceFile(PsaManager.Instance.LoadedPsaPath, destinationPath);
        }

        AssetDatabase.Refresh();
    }

    /// <summary>
    /// Called in the position loop to test every position to see if it hangs on a bar or peg.
    /// </summary>
    /// <param name="positionGO"></param>
    public void CheckProductForBarIntersection(GameObject positionGO, PsaIntegrationLibraryEventHandlers.SpawnedPlanogram planogramInfo)
    {
        if (planogramInfo.PlanogramPsaData == null
            || planogramInfo.BarAndPegboardGOs == null 
            || planogramInfo.ShelfFixtureGOs == null)
        {
            return;
        }

        //make a list of the products under the position
        Product[] childProducts = positionGO.GetComponentsInChildren<Product>();
        
        //get the collider so we can get its bounds
        Collider productCollider = positionGO.GetComponent<Collider>();

        //get the bounds from the collider so we can test what it intersects
        Bounds productBarBounds = GetUnstableIntermediateBounds(productCollider);
        Bounds productShelfBounds = GetUnstableIntermediateBounds(productCollider);

        // But modify the size on the z axis because bars don't actually touch products
        // Also decrease the size on the x axis so edge products don't pick up the next shelf accidentally
        Vector3 modifiedBarTestSize = productBarBounds.size;
        modifiedBarTestSize.x *= 0.9f;
        modifiedBarTestSize.z += planogramInfo.PlanogramPsaData.Depth;
        productBarBounds.size = modifiedBarTestSize;

        // But modify the size on the y axis because shelves don't actually touch products
        // Also decrease the size on the x axis so edge products don't pick up the next shelf accidentally
        Vector3 modifiedShelfTestSize = productShelfBounds.size;
        modifiedShelfTestSize.x *= 0.9f;
        modifiedShelfTestSize.y += 0.01f;
        productShelfBounds.size = modifiedShelfTestSize;

        // And modify the center to only extend the shelf check area downwards
        Vector3 modifiedShelfTestCenter = productShelfBounds.center;
        modifiedShelfTestCenter.y -= modifiedShelfTestSize.y / 2;
        productShelfBounds.center = modifiedShelfTestCenter;
        
        //if the product intersects with a bar and not a shelf then we can assume that the products are meant to be placed on a bar
        if (IntersectsAny(productBarBounds, planogramInfo.BarAndPegboardGOs) && !IntersectsAny(productShelfBounds, planogramInfo.ShelfFixtureGOs))
        {
            //because we intersect tell each of the products that we're meant to be placed on a peg
            foreach (Product childProductScript in childProducts)
            {
                childProductScript.pegProduct = true;

                childProductScript.GetComponent<Rigidbody>().isKinematic = true;
            }
        }
    }

    private bool IntersectsAny(Bounds intersectorBounds, List<GameObject> checkIntersectedObjects)
    {
        bool intersectionFound = false;

        foreach (GameObject intersectedObj in checkIntersectedObjects)
        {
            //get the bounds from the possible intersected object to test for intersection
            Collider intersectedCollider = intersectedObj.GetComponent<Collider>();
            Bounds intersectedBounds = GetUnstableIntermediateBounds(intersectedCollider);
            
            if (intersectorBounds.Intersects(intersectedBounds))
            {
                intersectionFound = true;
                break;
            }
        }

        return intersectionFound;
    }
     
    /// <summary>
    ///Add whatever special components we need for the back row objects
    /// </summary>
    public void ApplyOVRComponents(GameObject emptyParentObject, PSA.Product product, PSA.Position position, bool is3D)
    {
        bool hasOVRScripts = CheckForExistingScriptShelfCreator.IsValidClassShelfCreator("OVRGrabbable");

        if (!hasOVRScripts)
        {
            Debug.Log("Attention: OVRGrabbable not added to products because the VRCharacterController plugin is not present. If building for VR, please import VRCharacterController package and build shelf again.");
        }
        if (hasOVRScripts)
        {
            emptyParentObject.AddComponent(Type.GetType("OVRGrabbable"));
        }

        //add a box collider
        BoxCollider backRowObjectCollider = emptyParentObject.AddComponent<BoxCollider>();

        //get the real size of the products
        Vector3 productSize = new Vector3(PsaProductPostionBuilder.GetIndividualRealWidth(product, position.Orientation),
                                          PsaProductPostionBuilder.GetIndividualRealHeight(product, position.Orientation),
                                          PsaProductPostionBuilder.GetIndividualRealDepth(product, position.Orientation));
        //apply the real size to the box collider
        //reduce the x size of the collider to only 70% to prevent too many collisions
        backRowObjectCollider.size = new Vector3(productSize.x * 0.7f, productSize.y, productSize.z);
        //adjust the center based on the new box collider size
        backRowObjectCollider.center = new Vector3(productSize.x / -2f,
                                                    backRowObjectCollider.size.y / 2f,
                                                    backRowObjectCollider.size.z / 2f);
        //add a rigidbody
        emptyParentObject.AddComponent<Rigidbody>();
    }


    /// <summary>
    /// Creates or updates the prefab for this shelf strategy in the specified location
    /// </summary>
    /// <param name="newParent">The shelf GameObject. We'll update the prefab to match this object.</param>
    /// <param name="saveFolder">The path of the folder to save the prefab in.</param>
    /// <param name="prefabPath">The full path of where we want to save the prefab.</param>
    /// <returns>The updated reference to newParent (which changes from its original state when we connect it to the prefab).</returns>
    GameObject SetUpPrefab(GameObject newParent, string saveFolder, string prefabPath)
    {
        // Find the existing prefab so that we can update it
        UnityEngine.Object prefab = null;
        prefab = (GameObject)AssetDatabase.LoadAssetAtPath(prefabPath, typeof(GameObject));

        // If the prefab wasn't already there
        if (prefab == null)
        {
            // Make sure the folder we want to save the prefab in exists
            CreateFoldersForPath(saveFolder);
        }

        // Create the prefab of the shelf in the project and connect it to this instance of the shelf
        prefab = PrefabUtility.SaveAsPrefabAssetAndConnect(newParent, prefabPath, InteractionMode.AutomatedAction);

        return newParent;
    }

    /// <summary>
    /// Divide the shelf into segments. Should be called before layers are created.
    /// </summary>
    void SetPositionsToChildrenOfSegments(PsaIntegrationLibraryEventHandlers.SpawnedPlanogram planogramInfo)
    {
        if (planogramInfo.PositionsGOs == null || planogramInfo.SegmentGOs == null)
        {
            return;
        }

        //go through the list of positions
        foreach (GameObject positionObject in planogramInfo.PositionsGOs)
        {
            Collider positionCollider = positionObject.GetComponent<Collider>();
            Bounds positionBounds = GetUnstableIntermediateBounds(positionCollider);

            //this is populated by the best fit segment gameobject we find
            GameObject bestFitSegment = null;
            float distanceToBestFitSegment = float.MaxValue;
            //check each segment to see which segment the position is the most in.
            foreach (GameObject segmentObject in planogramInfo.SegmentGOs)
            {
                Collider segmentCollider = segmentObject.GetComponent<Collider>();
                Bounds segmentBounds = GetUnstableIntermediateBounds(segmentCollider);

                if (positionBounds.Intersects(segmentBounds))
                {
                    //we get how close the center of the bounds is to the center of the segment
                    float distanceToCurrentSegment = Vector3.Distance(positionBounds.center, segmentBounds.center);

                    //if the distance is less than the current lowest distance then we accept that we're closest to that particular segment
                    if (distanceToCurrentSegment < distanceToBestFitSegment)
                    {
                        distanceToBestFitSegment = distanceToCurrentSegment;
                        //this is the best segment fit we have
                        bestFitSegment = segmentObject;
                    }
                }
            }

            if (bestFitSegment != null)
            {
                //make our best fit segment the parent of the object
                positionObject.transform.parent = bestFitSegment.transform;
            }

        }
    }

    /// <summary>
    /// Divide the Segments into layers. Should be called after segments are created.
    /// </summary>
    void SetPositionsToChildrenOfLayers(PsaIntegrationLibraryEventHandlers.SpawnedPlanogram planogramInfo)
    {
        if (planogramInfo.SegmentGOs == null)
        {
            return;
        }

        //get each segment
        foreach (GameObject segmentObject in planogramInfo.SegmentGOs)
        {
            List<float> layerHeights = new List<float>();

            //Do this for each position in the segment object
            foreach (Transform child in segmentObject.transform)
            {
                if (layerHeights.Contains(child.localPosition.y))
                {
                    //print("already there");
                }
                else
                {
                    layerHeights.Add(child.localPosition.y);
                }
            }

            //sort the layers so they are instantiated and numbered in a logical order
            layerHeights.Sort();

            List<GameObject> layerGOs = new List<GameObject>();

            //then for each separate layer
            for (int i = 0; i < layerHeights.Count; i++)
            {
                //we create an empty layer object
                GameObject layerObject = new GameObject();
                layerObject.transform.parent = segmentObject.transform;
                //place it according to its layerheight
                layerObject.transform.localPosition = new Vector3(segmentObject.transform.localPosition.x, layerHeights[i], segmentObject.transform.localPosition.z);

                layerObject.name = "Layer_" + i.ToString();

                layerGOs.Add(layerObject);
            }
            //get a list of the positions, because we want to only affect objects that are positions
            Position[] childrenPositions = segmentObject.transform.GetComponentsInChildren<Position>();

            List<Transform> children = new List<Transform>();
            //get the transform of each position
            foreach (Position foundScript in childrenPositions)
            {
                children.Add(foundScript.transform);
            }

            Transform closestPoint = null;

            //find what layer the position is closest to.
            foreach (Transform child in children)
            {
                closestPoint = null;

                foreach (GameObject fixGO in layerGOs)
                {
                    if (closestPoint != null)
                    {
                        float currentDistance = Vector3.Distance(child.position, closestPoint.position);
                        float newDistance = Vector3.Distance(child.position, fixGO.transform.position);

                        //if this is closer than our previous closest distance then it's our new transform
                        if (newDistance < currentDistance)
                        {
                            closestPoint = fixGO.transform;
                        }

                    }
                    else
                    {
                        closestPoint = fixGO.transform;
                    }
                }
                //set our parent to the closest layer we could find
                child.SetParent(closestPoint);
            }
            //delete any empty layers
            foreach (GameObject layerGO in layerGOs)
            {
                if (layerGO.transform.childCount == 0)
                {
                    DestroyImmediate(layerGO);
                }
            }
        }
    }

    /// <summary>
    /// Resize the parent object based on metric or imperial units
    /// </summary>
    public void SetTrueScale(GameObject newParent)
    {
        float conversionScale = GetConversionFactor();

        //set the scale
        newParent.transform.localScale = new Vector3(conversionScale, conversionScale, conversionScale);
    }

    /// <summary>
    /// Return the correct adjustment factor for newPSA to account for metric or imperial units
    /// </summary>
    float GetConversionFactor()
    {
        float conversionScale;

        if (PsaManager.Instance.LoadedPSA.TheProject.Measurement == PSA.Project.MeasurementSystem.Metric)
        {
            conversionScale = METRIC_CONVERSION_FACTOR;
        }
        else
        {
            conversionScale = IMPERIAL_CONVERSION_FACTOR;
        }
        
        return conversionScale;
    }
    
    /// <summary>
    /// Adjust an already-spawned segment to fit our purposes.
    /// </summary>
    public void AdjustSegment(PSA.Planogram thePlanogram, GameObject segmentObject)
    {
        // Find the scale of the segment object
        Vector3 scale = segmentObject.transform.localScale;
        Vector3 position = segmentObject.transform.localPosition;

        if (scale.x == 0)
        {
            float defaultWidth = 48.0f; // 4 foot segment as default
            scale.x = defaultWidth;
            position.x = defaultWidth / 2;
        }

        if (scale.y == 0)
        {
            scale.y = thePlanogram.Height;
            position.y = thePlanogram.Height / 2;
        }

        if (scale.z == 0)
        {
            scale.z = thePlanogram.Depth;
            position.z = thePlanogram.Depth / 2;
        }
        
        segmentObject.transform.localScale = scale;
        segmentObject.transform.localPosition = position;

        // Mark the segment as a trigger to avoid collisions with products
        segmentObject.GetComponent<Collider>().isTrigger = true;
    }

    /// <summary>
    /// Creates the folders in the specified path if they don't already exist.
    /// </summary>
    /// <param name="path">The full filepath of the deepest folder to be created.</param>
    public static void CreateFoldersForPath(string path)
    {
        // Get the names of all of the folders
        string[] split = path.Split('/');

        string parentFolderPath = "";
        string currentFolder = "";

        // For each folder level
        for (int i = 0; i < split.Length; i++)
        {
            currentFolder = split[i];

            // Assemble the full path string
            string fullPath = parentFolderPath;
            if (parentFolderPath.Length > 0)
            {
                fullPath += "/";
            }
            fullPath += currentFolder;

            // If this folder doesn't exist
            if (!AssetDatabase.IsValidFolder(fullPath))
            {
                // Create it
                AssetDatabase.CreateFolder(parentFolderPath, currentFolder);
            }

            // Update the parent folder path for the next iteration of the loop
            parentFolderPath = fullPath;
        }
    }

    public static void SetOrganizeProductsBySegmentAndLayerOption(bool newValue)
    {
        // Apply the new walk speed value
        organizeProductsBySegmentAndLayer = newValue;

        // Update this value in the player prefs
        PlayerPrefs.SetInt(ORGANIZE_PRODUCTS_BY_SEGMENT_AND_LAYER, newValue ? 1 : 0);
        PlayerPrefs.Save();
    }

    public static void SetUpgradedFromOldUnityVersion(bool newValue)
    {
        createdInUnityVersionOlderThan2018_3 = newValue;

        // Update this value in the player prefs
        PlayerPrefs.SetInt(CREATED_IN_UNITY_VERSION_OLDER_THAN_2018_3, newValue ? 1 : 0);
        PlayerPrefs.Save();
    }

    /// <summary>
    /// Retrieves the bounds of products, bars, and shelves while the PSA is still being generated, and applies
    /// necessary adjustments based on the current Unity version.
    /// </summary>
    /// <param name="collider">The collider to retrieve the bounds of.</param>
    /// <returns>The bounds of the collider, adjusted to account for differences between Unity versions.</returns>
    public static Bounds GetUnstableIntermediateBounds(Collider collider)
    {
        Bounds worldBounds = collider.bounds;

#if UNITY_2018_3_OR_NEWER
        if (!createdInUnityVersionOlderThan2018_3)
        {
            /*
         * In Unity 2018.2.3f1, using `collider.bounds` worked fine, but upon upgrading to 2018.3.14f1, 
         * the values for `collider.bounds` are incorrect during PSA generation (though once the shelf 
         * is complete, they appear to be fine).
         * 
         * I don't know why this is different between the different versions, and I don't know why the 
         * center and extents need to be changed in different ways for different types of game objects,
         * but until we figure out the root of the issue, we're unfortunately going to need to use this 
         * weird, makeshift solution.
         */

            if (collider.gameObject.name.IndexOf('_') == 1) //Products and positions
            {
                Vector3 adjustedCenter = worldBounds.center;
                adjustedCenter.x += collider.transform.position.x;
                adjustedCenter.y += collider.transform.position.y;
                worldBounds.center = adjustedCenter;
            }
            else //everything else
            {
                worldBounds.center = collider.transform.position;
            }

            Vector3 adjustedExtents = worldBounds.extents;
            adjustedExtents.x *= collider.transform.localScale.x;
            adjustedExtents.y *= collider.transform.localScale.y;
            adjustedExtents.z *= collider.transform.localScale.z;
            worldBounds.extents = adjustedExtents;
        }
#endif

        return worldBounds;
    }
#endif
}
